<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pytransform3d.rotations &#8212; pytransform3d 1.4 documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          pytransform3d</a>
        <span class="navbar-text navbar-version pull-left"><b>1.4</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../rotations.html">3D Rotations: SO(3)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../transformations.html">3D Transformations: SE(3)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../transformation_ambiguities.html">Transformation Ambiguities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../transformation_modeling.html">Modeling Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../transform_manager.html">Transform Manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../camera.html">Camera</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../animations.html">Animations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Documentation</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for pytransform3d.rotations</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Rotations in three dimensions - SO(3).&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.testing</span> <span class="kn">import</span> <span class="n">assert_array_almost_equal</span>


<span class="n">unitx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="n">unity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="n">unitz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>

<span class="n">R_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">a_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="n">q_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="n">q_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="n">q_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="n">q_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="n">e_xyz_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="n">e_zyx_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>

<span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-7</span>


<div class="viewcode-block" id="norm_vector"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.norm_vector.html#pytransform3d.rotations.norm_vector">[docs]</a><span class="k">def</span> <span class="nf">norm_vector</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalize vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array-like, shape (n,)</span>
<span class="sd">        nd vector</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    u : array-like, shape (n,)</span>
<span class="sd">        nd unit vector with norm 1 or the zero vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">v</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm</span></div>


<div class="viewcode-block" id="norm_angle"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.norm_angle.html#pytransform3d.rotations.norm_angle">[docs]</a><span class="k">def</span> <span class="nf">norm_angle</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalize angle to (-pi, pi].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : float or array-like, shape (n,)</span>
<span class="sd">        Angle(s) in radians</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a_norm : float or array-like, shape (n,)</span>
<span class="sd">        Normalized angle(s) in radians</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Source of the solution: http://stackoverflow.com/a/32266181</span>
    <span class="k">return</span> <span class="o">-</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">%</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span></div>


<div class="viewcode-block" id="norm_axis_angle"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.norm_axis_angle.html#pytransform3d.rotations.norm_axis_angle">[docs]</a><span class="k">def</span> <span class="nf">norm_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalize axis-angle representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like, shape (4,)</span>
<span class="sd">        Axis of rotation and rotation angle: (x, y, z, angle)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array-like, shape (4,)</span>
<span class="sd">        Axis of rotation and rotation angle: (x, y, z, angle). The length</span>
<span class="sd">        of the axis vector is 1 and the angle is in [0, pi). No rotation</span>
<span class="sd">        is represented by [1, 0, 0, 0].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">angle</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">norm</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">res</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="n">norm</span>

    <span class="n">angle</span> <span class="o">=</span> <span class="n">norm_angle</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">angle</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="n">res</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>

    <span class="n">res</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span>

    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="norm_compact_axis_angle"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.norm_compact_axis_angle.html#pytransform3d.rotations.norm_compact_axis_angle">[docs]</a><span class="k">def</span> <span class="nf">norm_compact_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalize compact axis-angle representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like, shape (3,)</span>
<span class="sd">        Axis of rotation and rotation angle: angle * (x, y, z)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array-like, shape (3,)</span>
<span class="sd">        Axis of rotation and rotation angle: angle * (x, y, z).</span>
<span class="sd">        The angle is in [0, pi). No rotation is represented by [0, 0, 0].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">angle</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">angle</span>
    <span class="k">return</span> <span class="n">axis</span> <span class="o">*</span> <span class="n">norm_angle</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span></div>


<div class="viewcode-block" id="perpendicular_to_vectors"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.perpendicular_to_vectors.html#pytransform3d.rotations.perpendicular_to_vectors">[docs]</a><span class="k">def</span> <span class="nf">perpendicular_to_vectors</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute perpendicular vector to two other vectors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like, shape (3,)</span>
<span class="sd">        3d vector</span>

<span class="sd">    b : array-like, shape (3,)</span>
<span class="sd">        3d vector</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    c : array-like, shape (3,)</span>
<span class="sd">        3d vector that is orthogonal to a and b</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">perpendicular_to_vector</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute perpendicular vector to one other vector.</span>

<span class="sd">    There is an infinite number of solutions to this problem. Thus, we</span>
<span class="sd">    restrict the solutions to [1, 0, z] and return [0, 0, 1] if the</span>
<span class="sd">    z component of a is 0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like, shape (3,)</span>
<span class="sd">        3d vector</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : array-like, shape (3,)</span>
<span class="sd">        A 3d vector that is orthogonal to a. It does not necessarily have</span>
<span class="sd">        unit length.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">unitz</span><span class="p">)</span>
    <span class="c1"># Now that we solved the problem for [x, y, 0], we can solve it for all</span>
    <span class="c1"># other vectors by restricting solutions to [1, 0, z] and find z.</span>
    <span class="c1"># The dot product of orthogonal vectors is 0, thus</span>
    <span class="c1"># a[0] * 1 + a[1] * 0 + a[2] * z == 0 or -a[0] / a[2] = z</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>


<div class="viewcode-block" id="angle_between_vectors"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.angle_between_vectors.html#pytransform3d.rotations.angle_between_vectors">[docs]</a><span class="k">def</span> <span class="nf">angle_between_vectors</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute angle between two vectors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like, shape (n,)</span>
<span class="sd">        nd vector</span>

<span class="sd">    b : array-like, shape (n,)</span>
<span class="sd">        nd vector</span>

<span class="sd">    fast : bool, optional (default: False)</span>
<span class="sd">        Use fast implementation instead of numerically stable solution</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    angle : float</span>
<span class="sd">        Angle between a and b</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">fast</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">)),</span>
                    <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span></div>


<div class="viewcode-block" id="random_vector"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.random_vector.html#pytransform3d.rotations.random_vector">[docs]</a><span class="k">def</span> <span class="nf">random_vector</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate an nd vector with normally distributed components.</span>

<span class="sd">    Each component will be sampled from :math:`\mathcal{N}(\mu=0, \sigma=1)`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    random_state : np.random.RandomState, optional (default: random seed 0)</span>
<span class="sd">        Random number generator</span>

<span class="sd">    n : int, optional (default: 3)</span>
<span class="sd">        Number of vector components</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    v : array-like, shape (n,)</span>
<span class="sd">        Random vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">random_state</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>


<div class="viewcode-block" id="random_axis_angle"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.random_axis_angle.html#pytransform3d.rotations.random_axis_angle">[docs]</a><span class="k">def</span> <span class="nf">random_axis_angle</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;Generate random axis-angle.</span>

<span class="sd">    The angle will be sampled uniformly from the interval :math:`[0, \pi)`</span>
<span class="sd">    and each component of the rotation axis will be sampled from</span>
<span class="sd">    :math:`\mathcal{N}(\mu=0, \sigma=1)` and than the axis will be normalized</span>
<span class="sd">    to length 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    random_state : np.random.RandomState, optional (default: random seed 0)</span>
<span class="sd">        Random number generator</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array-like, shape (4,)</span>
<span class="sd">        Axis of rotation and rotation angle: (x, y, z, angle)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">random_state</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">angle</span><span class="p">])</span>
    <span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm_vector</span><span class="p">(</span><span class="n">random_state</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">a</span></div>


<div class="viewcode-block" id="random_compact_axis_angle"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.random_compact_axis_angle.html#pytransform3d.rotations.random_compact_axis_angle">[docs]</a><span class="k">def</span> <span class="nf">random_compact_axis_angle</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;Generate random compact axis-angle.</span>

<span class="sd">    The angle will be sampled uniformly from the interval :math:`[0, \pi)`</span>
<span class="sd">    and each component of the rotation axis will be sampled from</span>
<span class="sd">    :math:`\mathcal{N}(\mu=0, \sigma=1)` and than the axis will be normalized</span>
<span class="sd">    to length 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    random_state : np.random.RandomState, optional (default: random seed 0)</span>
<span class="sd">        Random number generator</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array-like, shape (3,)</span>
<span class="sd">        Axis of rotation and rotation angle: angle * (x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">random_axis_angle</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span></div>


<div class="viewcode-block" id="random_quaternion"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.random_quaternion.html#pytransform3d.rotations.random_quaternion">[docs]</a><span class="k">def</span> <span class="nf">random_quaternion</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;Generate random quaternion.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    random_state : np.random.RandomState, optional (default: random seed 0)</span>
<span class="sd">        Random number generator</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    q : array-like, shape (4,)</span>
<span class="sd">        Unit quaternion to represent rotation: (w, x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">norm_vector</span><span class="p">(</span><span class="n">random_state</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span></div>


<div class="viewcode-block" id="cross_product_matrix"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.cross_product_matrix.html#pytransform3d.rotations.cross_product_matrix">[docs]</a><span class="k">def</span> <span class="nf">cross_product_matrix</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate the cross-product matrix of a vector.</span>

<span class="sd">    The cross-product matrix :math:`\\boldsymbol{V}` satisfies the equation</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\boldsymbol{V} \\boldsymbol{w} = \\boldsymbol{v} \\times</span>
<span class="sd">        \\boldsymbol{w}</span>

<span class="sd">    It is a skew-symmetric (antisymmetric) matrix, i.e.</span>
<span class="sd">    :math:`-\\boldsymbol{V} = \\boldsymbol{V}^T`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : array-like, shape (3,)</span>
<span class="sd">        3d vector</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    V : array-like, shape (3, 3)</span>
<span class="sd">        Cross-product matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                     <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                     <span class="p">[</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">]])</span></div>


<div class="viewcode-block" id="check_matrix"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.check_matrix.html#pytransform3d.rotations.check_matrix">[docs]</a><span class="k">def</span> <span class="nf">check_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">strict_check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Input validation of a rotation matrix.</span>

<span class="sd">    We check whether R multiplied by its inverse is approximately the identity</span>
<span class="sd">    matrix and the determinant is approximately 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>

<span class="sd">    tolerance : float, optional (default: 1e-6)</span>
<span class="sd">        Tolerance threshold for checks. Default tolerance is the same as in</span>
<span class="sd">        assert_rotation_matrix(R).</span>

<span class="sd">    strict_check : bool, optional (default: True)</span>
<span class="sd">        Raise a ValueError if the rotation matrix is not numerically close</span>
<span class="sd">        enough to a real rotation matrix. Otherwise we print a warning.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : array, shape (3, 3)</span>
<span class="sd">        Validated rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">R</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected rotation matrix with shape (3, 3), got &quot;</span>
                         <span class="s2">&quot;array-like object with shape </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
    <span class="n">RRT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">RRT</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">):</span>
        <span class="n">error_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Expected rotation matrix, but it failed the test &quot;</span>
                     <span class="s2">&quot;for inversion by transposition. np.dot(R, R.T) &quot;</span>
                     <span class="s2">&quot;gives </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">RRT</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strict_check</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
    <span class="n">R_det</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">R_det</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
        <span class="n">error_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Expected rotation matrix, but it failed the test &quot;</span>
                     <span class="s2">&quot;for the determinant, which should be 1 but is </span><span class="si">%g</span><span class="s2">; &quot;</span>
                     <span class="s2">&quot;that is, it probably represents a rotoreflection&quot;</span>
                     <span class="o">%</span> <span class="n">R_det</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strict_check</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="check_axis_angle"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.check_axis_angle.html#pytransform3d.rotations.check_axis_angle">[docs]</a><span class="k">def</span> <span class="nf">check_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Input validation of axis-angle representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like, shape (4,)</span>
<span class="sd">        Axis of rotation and rotation angle: (x, y, z, angle)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array, shape (4,)</span>
<span class="sd">        Validated axis of rotation and rotation angle: (x, y, z, angle)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected axis and angle in array with shape (4,), &quot;</span>
                         <span class="s2">&quot;got array-like object with shape </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
    <span class="k">return</span> <span class="n">norm_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>


<div class="viewcode-block" id="check_compact_axis_angle"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.check_compact_axis_angle.html#pytransform3d.rotations.check_compact_axis_angle">[docs]</a><span class="k">def</span> <span class="nf">check_compact_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Input validation of compact axis-angle representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like, shape (3,)</span>
<span class="sd">        Axis of rotation and rotation angle: angle * (x, y, z)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array, shape (3,)</span>
<span class="sd">        Validated axis of rotation and rotation angle: angle * (x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected axis and angle in array with shape (3,), &quot;</span>
                         <span class="s2">&quot;got array-like object with shape </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
    <span class="k">return</span> <span class="n">norm_compact_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>


<div class="viewcode-block" id="check_quaternion"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.check_quaternion.html#pytransform3d.rotations.check_quaternion">[docs]</a><span class="k">def</span> <span class="nf">check_quaternion</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Input validation of quaternion representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q : array-like, shape (4,)</span>
<span class="sd">        Quaternion to represent rotation: (w, x, y, z)</span>

<span class="sd">    unit : bool, optional (default: True)</span>
<span class="sd">        Normalize the quaternion so that it is a unit quaternion</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    q : array-like, shape (4,)</span>
<span class="sd">        Validated quaternion to represent rotation: (w, x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected quaternion with shape (4,), got &quot;</span>
                         <span class="s2">&quot;array-like object with shape </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">unit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">norm_vector</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">q</span></div>


<div class="viewcode-block" id="check_quaternions"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.check_quaternions.html#pytransform3d.rotations.check_quaternions">[docs]</a><span class="k">def</span> <span class="nf">check_quaternions</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Input validation of quaternion representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Q : array-like, shape (n_steps, 4)</span>
<span class="sd">        Quaternions to represent rotations: (w, x, y, z)</span>

<span class="sd">    unit : bool, optional (default: True)</span>
<span class="sd">        Normalize the quaternions so that they are unit quaternions</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Q : array-like, shape (n_steps, 4)</span>
<span class="sd">        Validated quaternions to represent rotations: (w, x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Q_checked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Q_checked</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">Q_checked</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected quaternion array with shape (n_steps, 4), got &quot;</span>
                         <span class="s2">&quot;array-like object with shape </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">Q_checked</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">unit</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Q</span><span class="p">)):</span>
            <span class="n">Q_checked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm_vector</span><span class="p">(</span><span class="n">Q_checked</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">Q_checked</span></div>


<div class="viewcode-block" id="matrix_from_axis_angle"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.matrix_from_axis_angle.html#pytransform3d.rotations.matrix_from_axis_angle">[docs]</a><span class="k">def</span> <span class="nf">matrix_from_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute rotation matrix from axis-angle.</span>

<span class="sd">    This is called exponential map or Rodrigues&#39; formula.</span>

<span class="sd">    This typically results in an active rotation matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like, shape (4,)</span>
<span class="sd">        Axis of rotation and rotation angle: (x, y, z, angle)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">check_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">ux</span><span class="p">,</span> <span class="n">uy</span><span class="p">,</span> <span class="n">uz</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">ci</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">c</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">ci</span> <span class="o">*</span> <span class="n">ux</span> <span class="o">*</span> <span class="n">ux</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span>
                   <span class="n">ci</span> <span class="o">*</span> <span class="n">ux</span> <span class="o">*</span> <span class="n">uy</span> <span class="o">-</span> <span class="n">uz</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span>
                   <span class="n">ci</span> <span class="o">*</span> <span class="n">ux</span> <span class="o">*</span> <span class="n">uz</span> <span class="o">+</span> <span class="n">uy</span> <span class="o">*</span> <span class="n">s</span><span class="p">],</span>
                  <span class="p">[</span><span class="n">ci</span> <span class="o">*</span> <span class="n">uy</span> <span class="o">*</span> <span class="n">ux</span> <span class="o">+</span> <span class="n">uz</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span>
                   <span class="n">ci</span> <span class="o">*</span> <span class="n">uy</span> <span class="o">*</span> <span class="n">uy</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span>
                   <span class="n">ci</span> <span class="o">*</span> <span class="n">uy</span> <span class="o">*</span> <span class="n">uz</span> <span class="o">-</span> <span class="n">ux</span> <span class="o">*</span> <span class="n">s</span><span class="p">],</span>
                  <span class="p">[</span><span class="n">ci</span> <span class="o">*</span> <span class="n">uz</span> <span class="o">*</span> <span class="n">ux</span> <span class="o">-</span> <span class="n">uy</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span>
                   <span class="n">ci</span> <span class="o">*</span> <span class="n">uz</span> <span class="o">*</span> <span class="n">uy</span> <span class="o">+</span> <span class="n">ux</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span>
                   <span class="n">ci</span> <span class="o">*</span> <span class="n">uz</span> <span class="o">*</span> <span class="n">uz</span> <span class="o">+</span> <span class="n">c</span><span class="p">],</span>
                  <span class="p">])</span>

    <span class="c1"># This is equivalent to</span>
    <span class="c1"># R = (np.eye(3) * np.cos(a[3]) +</span>
    <span class="c1">#      (1.0 - np.cos(a[3])) * a[:3, np.newaxis].dot(a[np.newaxis, :3]) +</span>
    <span class="c1">#      cross_product_matrix(a[:3]) * np.sin(a[3]))</span>

    <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="matrix_from_compact_axis_angle"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.matrix_from_compact_axis_angle.html#pytransform3d.rotations.matrix_from_compact_axis_angle">[docs]</a><span class="k">def</span> <span class="nf">matrix_from_compact_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute rotation matrix from compact axis-angle.</span>

<span class="sd">    This is called exponential map or Rodrigues&#39; formula.</span>

<span class="sd">    This typically results in an active rotation matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like, shape (3,)</span>
<span class="sd">        Axis of rotation and rotation angle: angle * (x, y, z)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">axis_angle_from_compact_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">matrix_from_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>


<div class="viewcode-block" id="matrix_from_quaternion"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.matrix_from_quaternion.html#pytransform3d.rotations.matrix_from_quaternion">[docs]</a><span class="k">def</span> <span class="nf">matrix_from_quaternion</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute rotation matrix from quaternion.</span>

<span class="sd">    This typically results in an active rotation matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q : array-like, shape (4,)</span>
<span class="sd">        Unit quaternion to represent rotation: (w, x, y, z)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">check_quaternion</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">uq</span> <span class="o">=</span> <span class="n">norm_vector</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">uq</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>
    <span class="n">z2</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">z</span> <span class="o">*</span> <span class="n">z</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
    <span class="n">xz</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">z</span>
    <span class="n">yz</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span>
    <span class="n">xw</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">w</span>
    <span class="n">yw</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">w</span>
    <span class="n">zw</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">z</span> <span class="o">*</span> <span class="n">w</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">z2</span><span class="p">,</span> <span class="n">xy</span> <span class="o">-</span> <span class="n">zw</span><span class="p">,</span> <span class="n">xz</span> <span class="o">+</span> <span class="n">yw</span><span class="p">],</span>
                  <span class="p">[</span><span class="n">xy</span> <span class="o">+</span> <span class="n">zw</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">z2</span><span class="p">,</span> <span class="n">yz</span> <span class="o">-</span> <span class="n">xw</span><span class="p">],</span>
                  <span class="p">[</span><span class="n">xz</span> <span class="o">-</span> <span class="n">yw</span><span class="p">,</span> <span class="n">yz</span> <span class="o">+</span> <span class="n">xw</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">y2</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="matrix_from_angle"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.matrix_from_angle.html#pytransform3d.rotations.matrix_from_angle">[docs]</a><span class="k">def</span> <span class="nf">matrix_from_angle</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute passive rotation matrix from rotation around basis vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    basis : int from [0, 1, 2]</span>
<span class="sd">        The rotation axis (0: x, 1: y, 2: z)</span>

<span class="sd">    angle : float</span>
<span class="sd">        Rotation angle</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">],</span>
                      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">c</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">],</span>
                      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                      <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">c</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                      <span class="p">[</span><span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Basis must be in [0, 1, 2]&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">R</span></div>


<span class="n">passive_matrix_from_angle</span> <span class="o">=</span> <span class="n">matrix_from_angle</span>


<div class="viewcode-block" id="active_matrix_from_angle"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.active_matrix_from_angle.html#pytransform3d.rotations.active_matrix_from_angle">[docs]</a><span class="k">def</span> <span class="nf">active_matrix_from_angle</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute active rotation matrix from rotation around basis vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    basis : int from [0, 1, 2]</span>
<span class="sd">        The rotation axis (0: x, 1: y, 2: z)</span>

<span class="sd">    angle : float</span>
<span class="sd">        Rotation angle</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">],</span>
                      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">c</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">s</span><span class="p">],</span>
                      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                      <span class="p">[</span><span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">c</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                      <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Basis must be in [0, 1, 2]&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="matrix_from_euler_xyz"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.matrix_from_euler_xyz.html#pytransform3d.rotations.matrix_from_euler_xyz">[docs]</a><span class="k">def</span> <span class="nf">matrix_from_euler_xyz</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute passive rotation matrix from intrinsic xyz Tait-Bryan angles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    e : array-like, shape (3,)</span>
<span class="sd">        Angles for rotation around x-, y&#39;-, and z&#39;&#39;-axes (intrinsic rotations)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">e</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">passive_matrix_from_angle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">passive_matrix_from_angle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">beta</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">passive_matrix_from_angle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">gamma</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="matrix_from_euler_zyx"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.matrix_from_euler_zyx.html#pytransform3d.rotations.matrix_from_euler_zyx">[docs]</a><span class="k">def</span> <span class="nf">matrix_from_euler_zyx</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute passive rotation matrix from intrinsic zyx Tait-Bryan angles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    e : array-like, shape (3,)</span>
<span class="sd">        Angles for rotation around z-, y&#39;-, and x&#39;&#39;-axes (intrinsic rotations)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gamma</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">e</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">passive_matrix_from_angle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">passive_matrix_from_angle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">beta</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">passive_matrix_from_angle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="active_matrix_from_intrinsic_euler_zxz"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.active_matrix_from_intrinsic_euler_zxz.html#pytransform3d.rotations.active_matrix_from_intrinsic_euler_zxz">[docs]</a><span class="k">def</span> <span class="nf">active_matrix_from_intrinsic_euler_zxz</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute active rotation matrix from intrinsic zxz Euler angles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    e : array-like, shape (3,)</span>
<span class="sd">        Angles for rotation around z-, x&#39;-, and z&#39;&#39;-axes (intrinsic rotations)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">e</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">active_matrix_from_angle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">active_matrix_from_angle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">beta</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">active_matrix_from_angle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">gamma</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="active_matrix_from_extrinsic_euler_zxz"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.active_matrix_from_extrinsic_euler_zxz.html#pytransform3d.rotations.active_matrix_from_extrinsic_euler_zxz">[docs]</a><span class="k">def</span> <span class="nf">active_matrix_from_extrinsic_euler_zxz</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute active rotation matrix from extrinsic zxz Euler angles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    e : array-like, shape (3,)</span>
<span class="sd">        Angles for rotation around z-, x-, and z-axes (extrinsic rotations)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The difference between extrinsic and intrinsic rotation is the order of</span>
    <span class="c1"># rotations and because the reverse of zxz is zxz this is exactly the same.</span>
    <span class="k">return</span> <span class="n">active_matrix_from_intrinsic_euler_zxz</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></div>


<div class="viewcode-block" id="active_matrix_from_intrinsic_euler_zyz"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.active_matrix_from_intrinsic_euler_zyz.html#pytransform3d.rotations.active_matrix_from_intrinsic_euler_zyz">[docs]</a><span class="k">def</span> <span class="nf">active_matrix_from_intrinsic_euler_zyz</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute active rotation matrix from intrinsic zyz Euler angles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    e : array-like, shape (3,)</span>
<span class="sd">        Angles for rotation around z-, y&#39;-, and z&#39;&#39;-axes (intrinsic rotations)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">e</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">active_matrix_from_angle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">active_matrix_from_angle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">beta</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">active_matrix_from_angle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">gamma</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="active_matrix_from_extrinsic_euler_zyz"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.active_matrix_from_extrinsic_euler_zyz.html#pytransform3d.rotations.active_matrix_from_extrinsic_euler_zyz">[docs]</a><span class="k">def</span> <span class="nf">active_matrix_from_extrinsic_euler_zyz</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute active rotation matrix from extrinsic zyz Euler angles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    e : array-like, shape (3,)</span>
<span class="sd">        Angles for rotation around z-, y-, and z-axes (extrinsic rotations)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The difference between extrinsic and intrinsic rotation is the order of</span>
    <span class="c1"># rotations and because the reverse of zyz is zyz this is exactly the same.</span>
    <span class="k">return</span> <span class="n">active_matrix_from_intrinsic_euler_zyz</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></div>


<div class="viewcode-block" id="active_matrix_from_extrinsic_roll_pitch_yaw"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.active_matrix_from_extrinsic_roll_pitch_yaw.html#pytransform3d.rotations.active_matrix_from_extrinsic_roll_pitch_yaw">[docs]</a><span class="k">def</span> <span class="nf">active_matrix_from_extrinsic_roll_pitch_yaw</span><span class="p">(</span><span class="n">rpy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute active rotation matrix from extrinsic roll, pitch, and yaw.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rpy : array-like, shape (3,)</span>
<span class="sd">        Angles for rotation around x- (roll), y- (pitch), and z-axes (yaw), extrinsic rotations</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">roll</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">yaw</span> <span class="o">=</span> <span class="n">rpy</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">active_matrix_from_angle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">yaw</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">active_matrix_from_angle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pitch</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">active_matrix_from_angle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">roll</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="matrix_from"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.matrix_from.html#pytransform3d.rotations.matrix_from">[docs]</a><span class="k">def</span> <span class="nf">matrix_from</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">e_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">e_zyx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute rotation matrix from another representation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>

<span class="sd">    a : array-like, shape (4,)</span>
<span class="sd">        Axis of rotation and rotation angle: (x, y, z, angle)</span>

<span class="sd">    q : array-like, shape (4,)</span>
<span class="sd">        Unit quaternion to represent rotation: (w, x, y, z)</span>

<span class="sd">    e_xyz : array-like, shape (3,)</span>
<span class="sd">        Angles for rotation around x-, y&#39;-, and z&#39;&#39;-axes (intrinsic rotations)</span>

<span class="sd">    e_zyx : array-like, shape (3,)</span>
<span class="sd">        Angles for rotation around z-, y&#39;-, and x&#39;&#39;-axes (intrinsic rotations)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">R</span>
    <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">matrix_from_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">q</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">matrix_from_quaternion</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">e_xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">matrix_from_euler_xyz</span><span class="p">(</span><span class="n">e_xyz</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">e_zyx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">matrix_from_euler_zyx</span><span class="p">(</span><span class="n">e_zyx</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot compute rotation matrix from no rotation.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="euler_xyz_from_matrix"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.euler_xyz_from_matrix.html#pytransform3d.rotations.euler_xyz_from_matrix">[docs]</a><span class="k">def</span> <span class="nf">euler_xyz_from_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">strict_check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute xyz Euler angles from passive rotation matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Passive rotation matrix</span>

<span class="sd">    strict_check : bool, optional (default: True)</span>
<span class="sd">        Raise a ValueError if the rotation matrix is not numerically close</span>
<span class="sd">        enough to a real rotation matrix. Otherwise we print a warning.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    e_xyz : array-like, shape (3,)</span>
<span class="sd">        Angles for rotation around x-, y&#39;-, and z&#39;&#39;-axes (intrinsic rotations)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">check_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">strict_check</span><span class="o">=</span><span class="n">strict_check</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="c1"># NOTE: There are two solutions: angle2 and pi - angle2!</span>
        <span class="n">angle2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="o">-</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">angle1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle2</span><span class="p">),</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle2</span><span class="p">))</span>
        <span class="n">angle3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle2</span><span class="p">),</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">angle3</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">angle2</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">angle1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">angle3</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">angle2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">angle1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">angle1</span><span class="p">,</span> <span class="n">angle2</span><span class="p">,</span> <span class="n">angle3</span><span class="p">])</span></div>


<div class="viewcode-block" id="euler_zyx_from_matrix"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.euler_zyx_from_matrix.html#pytransform3d.rotations.euler_zyx_from_matrix">[docs]</a><span class="k">def</span> <span class="nf">euler_zyx_from_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">strict_check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute zyx Euler angles from passive rotation matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Passive rotation matrix</span>

<span class="sd">    strict_check : bool, optional (default: True)</span>
<span class="sd">        Raise a ValueError if the rotation matrix is not numerically close</span>
<span class="sd">        enough to a real rotation matrix. Otherwise we print a warning.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    e_zyx : array-like, shape (3,)</span>
<span class="sd">        Angles for rotation around z-, y&#39;-, and x&#39;&#39;-axes (intrinsic rotations)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">check_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">strict_check</span><span class="o">=</span><span class="n">strict_check</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="c1"># NOTE: There are two solutions: angle2 and pi - angle2!</span>
        <span class="n">angle2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">angle3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle2</span><span class="p">),</span>
                            <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle2</span><span class="p">))</span>
        <span class="n">angle1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle2</span><span class="p">),</span>
                            <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">angle3</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">angle2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">angle1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">angle3</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">angle2</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">angle1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">angle1</span><span class="p">,</span> <span class="n">angle2</span><span class="p">,</span> <span class="n">angle3</span><span class="p">])</span></div>


<div class="viewcode-block" id="axis_angle_from_matrix"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.axis_angle_from_matrix.html#pytransform3d.rotations.axis_angle_from_matrix">[docs]</a><span class="k">def</span> <span class="nf">axis_angle_from_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">strict_check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute axis-angle from rotation matrix.</span>

<span class="sd">    This operation is called logarithmic map. Note that there are two possible</span>
<span class="sd">    solutions for the rotation axis when the angle is 180 degrees (pi).</span>

<span class="sd">    We usually assume active rotations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>

<span class="sd">    strict_check : bool, optional (default: True)</span>
<span class="sd">        Raise a ValueError if the rotation matrix is not numerically close</span>
<span class="sd">        enough to a real rotation matrix. Otherwise we print a warning.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array-like, shape (4,)</span>
<span class="sd">        Axis of rotation and rotation angle: (x, y, z, angle). The angle is</span>
<span class="sd">        constrained to [0, pi].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">check_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">strict_check</span><span class="o">=</span><span class="n">strict_check</span><span class="p">)</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">angle</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># We can usually determine the rotation axis by inverting Rodrigues&#39;</span>
    <span class="c1"># formula. Subtracting opposing off-diagonal elements gives us</span>
    <span class="c1"># 2 * sin(angle) * e,</span>
    <span class="c1"># where e is the normalized rotation axis.</span>
    <span class="n">axis_unnormalized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">angle</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-4</span><span class="p">:</span>
        <span class="c1"># The threshold is a result from this discussion:</span>
        <span class="c1"># https://github.com/rock-learning/pytransform3d/issues/43</span>
        <span class="c1"># The standard formula becomes numerically unstable, however,</span>
        <span class="c1"># Rodrigues&#39; formula reduces to R = I + 2 (ee^T - I), with the</span>
        <span class="c1"># rotation axis e, that is, ee^T = 0.5 * (R + I) and we can find the</span>
        <span class="c1"># squared values of the rotation axis on the diagonal of this matrix.</span>
        <span class="c1"># We can still use the original formula to reconstruct the signs of</span>
        <span class="c1"># the rotation axis correctly.</span>
        <span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">axis_unnormalized</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis_unnormalized</span>
        <span class="c1"># The norm of axis_unnormalized is 2.0 * np.sin(angle), that is, we</span>
        <span class="c1"># could normalize with a[:3] = a[:3] / (2.0 * np.sin(angle)),</span>
        <span class="c1"># but the following is much more precise for angles close to 0 or pi:</span>
    <span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span>
    <span class="k">return</span> <span class="n">a</span></div>


<div class="viewcode-block" id="axis_angle_from_quaternion"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.axis_angle_from_quaternion.html#pytransform3d.rotations.axis_angle_from_quaternion">[docs]</a><span class="k">def</span> <span class="nf">axis_angle_from_quaternion</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute axis-angle from quaternion.</span>

<span class="sd">    This operation is called logarithmic map.</span>

<span class="sd">    We usually assume active rotations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q : array-like, shape (4,)</span>
<span class="sd">        Unit quaternion to represent rotation: (w, x, y, z)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array-like, shape (4,)</span>
<span class="sd">        Axis of rotation and rotation angle: (x, y, z, angle). The angle is</span>
<span class="sd">        constrained to [0, pi) so that the mapping is unique.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">check_quaternion</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">p_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p_norm</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="n">p_norm</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]),)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">axis</span><span class="p">,</span> <span class="n">angle</span><span class="p">))</span></div>


<div class="viewcode-block" id="axis_angle_from_compact_axis_angle"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.axis_angle_from_compact_axis_angle.html#pytransform3d.rotations.axis_angle_from_compact_axis_angle">[docs]</a><span class="k">def</span> <span class="nf">axis_angle_from_compact_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute axis-angle from compact axis-angle representation.</span>

<span class="sd">    We usually assume active rotations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like, shape (3,)</span>
<span class="sd">        Axis of rotation and rotation angle: angle * (x, y, z).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array-like, shape (4,)</span>
<span class="sd">        Axis of rotation and rotation angle: (x, y, z, angle). The angle is</span>
<span class="sd">        constrained to [0, pi].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">check_compact_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">angle</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">angle</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="n">angle</span><span class="p">,)))</span></div>


<div class="viewcode-block" id="axis_angle_from_two_directions"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.axis_angle_from_two_directions.html#pytransform3d.rotations.axis_angle_from_two_directions">[docs]</a><span class="k">def</span> <span class="nf">axis_angle_from_two_directions</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute axis-angle representation from two direction vectors.</span>

<span class="sd">    The rotation will transform direction vector a to direction vector b.</span>
<span class="sd">    The direction vectors don&#39;t have to be normalized as this will be</span>
<span class="sd">    done internally. Note that there is more than one possible solution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like, shape (3,)</span>
<span class="sd">        First direction vector</span>

<span class="sd">    b : array-like, shape (3,)</span>
<span class="sd">        Second direction vector</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array-like, shape (4,)</span>
<span class="sd">        Axis of rotation and rotation angle: (x, y, z, angle). The angle is</span>
<span class="sd">        constrained to [0, pi].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">norm_vector</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">norm_vector</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">cos_angle</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cos_angle</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
        <span class="c1"># For 180 degree rotations we have an infinite number of solutions,</span>
        <span class="c1"># but we have to pick one axis.</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">perpendicular_to_vector</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">aa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">aa</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm_vector</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">aa</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cos_angle</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">norm_axis_angle</span><span class="p">(</span><span class="n">aa</span><span class="p">)</span></div>


<div class="viewcode-block" id="compact_axis_angle"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.compact_axis_angle.html#pytransform3d.rotations.compact_axis_angle">[docs]</a><span class="k">def</span> <span class="nf">compact_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute 3-dimensional axis-angle from a 4-dimensional one.</span>

<span class="sd">    In a 3-dimensional axis-angle, the 4th dimension (the rotation) is</span>
<span class="sd">    represented by the norm of the rotation axis vector, which means we</span>
<span class="sd">    transform :math:`\\left( \\boldsymbol{\hat{e}}, \\theta \\right)` to</span>
<span class="sd">    :math:`\\theta \\boldsymbol{\hat{e}}`.</span>

<span class="sd">    We usually assume active rotations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like, shape (4,)</span>
<span class="sd">        Axis of rotation and rotation angle: (x, y, z, angle).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array-like, shape (3,)</span>
<span class="sd">        Axis of rotation and rotation angle: angle * (x, y, z) (compact</span>
<span class="sd">        representation).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">check_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span></div>


<div class="viewcode-block" id="compact_axis_angle_from_matrix"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.compact_axis_angle_from_matrix.html#pytransform3d.rotations.compact_axis_angle_from_matrix">[docs]</a><span class="k">def</span> <span class="nf">compact_axis_angle_from_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute compact axis-angle from rotation matrix.</span>

<span class="sd">    This operation is called logarithmic map. Note that there are two possible</span>
<span class="sd">    solutions for the rotation axis when the angle is 180 degrees (pi).</span>

<span class="sd">    We usually assume active rotations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>

<span class="sd">    strict_check : bool, optional (default: True)</span>
<span class="sd">        Raise a ValueError if the rotation matrix is not numerically close</span>
<span class="sd">        enough to a real rotation matrix. Otherwise we print a warning.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array-like, shape (3,)</span>
<span class="sd">        Axis of rotation and rotation angle: angle * (x, y, z). The angle is</span>
<span class="sd">        constrained to [0, pi].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">axis_angle_from_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">compact_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>


<div class="viewcode-block" id="compact_axis_angle_from_quaternion"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.compact_axis_angle_from_quaternion.html#pytransform3d.rotations.compact_axis_angle_from_quaternion">[docs]</a><span class="k">def</span> <span class="nf">compact_axis_angle_from_quaternion</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute compact axis-angle from quaternion (logarithmic map).</span>

<span class="sd">    We usually assume active rotations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q : array-like, shape (4,)</span>
<span class="sd">        Unit quaternion to represent rotation: (w, x, y, z)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array-like, shape (3,)</span>
<span class="sd">        Axis of rotation and rotation angle: angle * (x, y, z). The angle is</span>
<span class="sd">        constrained to [0, pi].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">axis_angle_from_quaternion</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">compact_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>


<div class="viewcode-block" id="quaternion_from_matrix"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.quaternion_from_matrix.html#pytransform3d.rotations.quaternion_from_matrix">[docs]</a><span class="k">def</span> <span class="nf">quaternion_from_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">strict_check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute quaternion from rotation matrix.</span>

<span class="sd">    We usually assume active rotations.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        When computing a quaternion from the rotation matrix there is a sign</span>
<span class="sd">        ambiguity: q and -q represent the same rotation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R : array-like, shape (3, 3)</span>
<span class="sd">        Rotation matrix</span>

<span class="sd">    strict_check : bool, optional (default: True)</span>
<span class="sd">        Raise a ValueError if the rotation matrix is not numerically close</span>
<span class="sd">        enough to a real rotation matrix. Otherwise we print a warning.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    q : array-like, shape (4,)</span>
<span class="sd">        Unit quaternion to represent rotation: (w, x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">check_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">strict_check</span><span class="o">=</span><span class="n">strict_check</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Source: http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">trace</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">sqrt_trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">trace</span><span class="p">)</span>
        <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sqrt_trace</span>
        <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">sqrt_trace</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">sqrt_trace</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">sqrt_trace</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="n">sqrt_trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">sqrt_trace</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sqrt_trace</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">sqrt_trace</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">sqrt_trace</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="n">sqrt_trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">sqrt_trace</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">sqrt_trace</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sqrt_trace</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">sqrt_trace</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sqrt_trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">sqrt_trace</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">sqrt_trace</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">sqrt_trace</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sqrt_trace</span>
    <span class="k">return</span> <span class="n">q</span></div>


<div class="viewcode-block" id="quaternion_from_axis_angle"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.quaternion_from_axis_angle.html#pytransform3d.rotations.quaternion_from_axis_angle">[docs]</a><span class="k">def</span> <span class="nf">quaternion_from_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute quaternion from axis-angle.</span>

<span class="sd">    This operation is called exponential map.</span>

<span class="sd">    We usually assume active rotations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like, shape (4,)</span>
<span class="sd">        Axis of rotation and rotation angle: (x, y, z, angle)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    q : array-like, shape (4,)</span>
<span class="sd">        Unit quaternion to represent rotation: (w, x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">check_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">q</span></div>


<div class="viewcode-block" id="quaternion_from_compact_axis_angle"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.quaternion_from_compact_axis_angle.html#pytransform3d.rotations.quaternion_from_compact_axis_angle">[docs]</a><span class="k">def</span> <span class="nf">quaternion_from_compact_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute quaternion from compact axis-angle (exponential map).</span>

<span class="sd">    We usually assume active rotations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like, shape (4,)</span>
<span class="sd">        Axis of rotation and rotation angle: angle * (x, y, z)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    q : array-like, shape (4,)</span>
<span class="sd">        Unit quaternion to represent rotation: (w, x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">axis_angle_from_compact_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">quaternion_from_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>


<div class="viewcode-block" id="quaternion_xyzw_from_wxyz"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.quaternion_xyzw_from_wxyz.html#pytransform3d.rotations.quaternion_xyzw_from_wxyz">[docs]</a><span class="k">def</span> <span class="nf">quaternion_xyzw_from_wxyz</span><span class="p">(</span><span class="n">q_wxyz</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts from w, x, y, z to x, y, z, w convention.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q_wxyz : array-like, shape (4,)</span>
<span class="sd">        Quaternion with scalar part before vector part</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    q_xyzw : array-like, shape (4,)</span>
<span class="sd">        Quaternion with scalar part after vector part</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q_wxyz</span> <span class="o">=</span> <span class="n">check_quaternion</span><span class="p">(</span><span class="n">q_wxyz</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q_wxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q_wxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">q_wxyz</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">q_wxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span></div>


<div class="viewcode-block" id="quaternion_wxyz_from_xyzw"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.quaternion_wxyz_from_xyzw.html#pytransform3d.rotations.quaternion_wxyz_from_xyzw">[docs]</a><span class="k">def</span> <span class="nf">quaternion_wxyz_from_xyzw</span><span class="p">(</span><span class="n">q_xyzw</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts from x, y, z, w to w, x, y, z convention.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q_xyzw : array-like, shape (4,)</span>
<span class="sd">        Quaternion with scalar part after vector part</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    q_wxyz : array-like, shape (4,)</span>
<span class="sd">        Quaternion with scalar part before vector part</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q_xyzw</span> <span class="o">=</span> <span class="n">check_quaternion</span><span class="p">(</span><span class="n">q_xyzw</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q_xyzw</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">q_xyzw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q_xyzw</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q_xyzw</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span></div>


<div class="viewcode-block" id="quaternion_integrate"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.quaternion_integrate.html#pytransform3d.rotations.quaternion_integrate">[docs]</a><span class="k">def</span> <span class="nf">quaternion_integrate</span><span class="p">(</span><span class="n">Qd</span><span class="p">,</span> <span class="n">q0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]),</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Integrate angular velocities to quaternions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : array-like, shape (n_steps, 3)</span>
<span class="sd">        Angular velocities in a compact axis-angle representation. Each angular</span>
<span class="sd">        velocity represents the rotational offset after one unit of time.</span>

<span class="sd">    q0 : array-like, shape (4,), optional (default: [1, 0, 0, 0])</span>
<span class="sd">        Unit quaternion to represent initial rotation: (w, x, y, z)</span>

<span class="sd">    dt : float, optional (default: 1)</span>
<span class="sd">        Time interval between steps.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Q : array-like, shape (n_steps, 4)</span>
<span class="sd">        Quaternions to represent rotations: (w, x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">Qd</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>
    <span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">q0</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Qd</span><span class="p">)):</span>
        <span class="n">qd</span> <span class="o">=</span> <span class="p">(</span><span class="n">Qd</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">Qd</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">Q</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate_quaternions</span><span class="p">(</span>
            <span class="n">quaternion_from_compact_axis_angle</span><span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">qd</span><span class="p">),</span> <span class="n">Q</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">Q</span></div>


<div class="viewcode-block" id="quaternion_gradient"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.quaternion_gradient.html#pytransform3d.rotations.quaternion_gradient">[docs]</a><span class="k">def</span> <span class="nf">quaternion_gradient</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Time-derivatives of a sequence of quaternions.</span>

<span class="sd">    Note that this function does not provide the exact same functionality for</span>
<span class="sd">    quaternions as [NumPy&#39;s gradient</span>
<span class="sd">    function](https://numpy.org/doc/stable/reference/generated/numpy.gradient.html)</span>
<span class="sd">    for positions. Gradients are always computed as central differences except</span>
<span class="sd">    the first and last gradient. We additionally accept a parameter dt that</span>
<span class="sd">    defines the time interval between each quaternion. Note that this means</span>
<span class="sd">    that we expect this to be constant for the whole sequence.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Q : array-like, shape (n_steps, 4)</span>
<span class="sd">        Quaternions to represent rotations: (w, x, y, z)</span>

<span class="sd">    dt : float, optional (default: 1)</span>
<span class="sd">        Time interval between steps. If you have non-constant dt, you can pass</span>
<span class="sd">        1 and manually divide angular velocities by their corresponding time</span>
<span class="sd">        interval afterwards.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : array-like, shape (n_steps, 3)</span>
<span class="sd">        Angular velocities in a compact axis-angle representation. Each angular</span>
<span class="sd">        velocity represents the rotational offset after one unit of time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">check_quaternions</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">Qd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">Q</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">Qd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">compact_axis_angle_from_quaternion</span><span class="p">(</span><span class="n">concatenate_quaternions</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q_conj</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="o">/</span> <span class="n">dt</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># divided by two because of central differences</span>
        <span class="n">Qd</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">compact_axis_angle_from_quaternion</span><span class="p">(</span><span class="n">concatenate_quaternions</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">q_conj</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">Qd</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">compact_axis_angle_from_quaternion</span><span class="p">(</span><span class="n">concatenate_quaternions</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">q_conj</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])))</span> <span class="o">/</span> <span class="n">dt</span>
    <span class="k">return</span> <span class="n">Qd</span></div>


<div class="viewcode-block" id="concatenate_quaternions"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.concatenate_quaternions.html#pytransform3d.rotations.concatenate_quaternions">[docs]</a><span class="k">def</span> <span class="nf">concatenate_quaternions</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Concatenate two quaternions.</span>

<span class="sd">    We use Hamilton&#39;s quaternion multiplication.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q1 : array-like, shape (4,)</span>
<span class="sd">        First quaternion</span>

<span class="sd">    q2 : array-like, shape (4,)</span>
<span class="sd">        Second quaternion</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    q12 : array-like, shape (4,)</span>
<span class="sd">        Quaternion that represents the concatenated rotation q1 * q2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">check_quaternion</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">q2</span> <span class="o">=</span> <span class="n">check_quaternion</span><span class="p">(</span><span class="n">q2</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">q12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">q12</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">q1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">q2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q1</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">q2</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">q12</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">q1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">q2</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">q2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">q1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">q1</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">q2</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">q12</span></div>


<div class="viewcode-block" id="q_prod_vector"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.q_prod_vector.html#pytransform3d.rotations.q_prod_vector">[docs]</a><span class="k">def</span> <span class="nf">q_prod_vector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply rotation represented by a quaternion to a vector.</span>

<span class="sd">    We use Hamilton&#39;s quaternion multiplication.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q : array-like, shape (4,)</span>
<span class="sd">        Unit quaternion to represent rotation: (w, x, y, z)</span>

<span class="sd">    v : array-like, shape (3,)</span>
<span class="sd">        3d vector</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : array-like, shape (3,)</span>
<span class="sd">        3d vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">check_quaternion</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">t</span><span class="p">)</span></div>


<div class="viewcode-block" id="q_conj"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.q_conj.html#pytransform3d.rotations.q_conj">[docs]</a><span class="k">def</span> <span class="nf">q_conj</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Conjugate of quaternion.</span>

<span class="sd">    The conjugate of a unit quaternion inverts the rotation represented by</span>
<span class="sd">    this unit quaternion. The conjugate of a quaternion q is often denoted</span>
<span class="sd">    as q*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q : array-like, shape (4,)</span>
<span class="sd">        Unit quaternion to represent rotation: (w, x, y, z)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    q_c : array-like, shape (4,)</span>
<span class="sd">        Conjugate (w, -x, -y, -z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">check_quaternion</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span></div>


<span class="k">def</span> <span class="nf">_slerp_weights</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">angle</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">angle</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">angle</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>


<div class="viewcode-block" id="axis_angle_slerp"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.axis_angle_slerp.html#pytransform3d.rotations.axis_angle_slerp">[docs]</a><span class="k">def</span> <span class="nf">axis_angle_slerp</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Spherical linear interpolation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start : array-like, shape (4,)</span>
<span class="sd">        Start axis of rotation and rotation angle: (x, y, z, angle)</span>

<span class="sd">    end : array-like, shape (4,)</span>
<span class="sd">        Goal axis of rotation and rotation angle: (x, y, z, angle)</span>

<span class="sd">    t : float in [0, 1]</span>
<span class="sd">        Position between start and goal</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array-like, shape (4,)</span>
<span class="sd">        Interpolated axis of rotation and rotation angle: (x, y, z, angle)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">check_axis_angle</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">check_axis_angle</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">start</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">end</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">_slerp_weights</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">w1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">w1</span><span class="p">,</span> <span class="n">w1</span><span class="p">,</span> <span class="n">w1</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">t</span><span class="p">)])</span>
    <span class="n">w2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">w2</span><span class="p">,</span> <span class="n">w2</span><span class="p">,</span> <span class="n">w2</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">start</span> <span class="o">+</span> <span class="n">w2</span> <span class="o">*</span> <span class="n">end</span></div>


<div class="viewcode-block" id="quaternion_slerp"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.quaternion_slerp.html#pytransform3d.rotations.quaternion_slerp">[docs]</a><span class="k">def</span> <span class="nf">quaternion_slerp</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Spherical linear interpolation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start : array-like, shape (4,)</span>
<span class="sd">        Start unit quaternion to represent rotation: (w, x, y, z)</span>

<span class="sd">    end : array-like, shape (4,)</span>
<span class="sd">        End unit quaternion to represent rotation: (w, x, y, z)</span>

<span class="sd">    t : float in [0, 1]</span>
<span class="sd">        Position between start and goal</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    q : array-like, shape (4,)</span>
<span class="sd">        Interpolated unit quaternion to represent rotation: (w, x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">check_quaternion</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">check_quaternion</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
    <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">_slerp_weights</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">start</span> <span class="o">+</span> <span class="n">w2</span> <span class="o">*</span> <span class="n">end</span></div>


<div class="viewcode-block" id="quaternion_dist"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.quaternion_dist.html#pytransform3d.rotations.quaternion_dist">[docs]</a><span class="k">def</span> <span class="nf">quaternion_dist</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute distance between two quaternions.</span>

<span class="sd">    We use the angular metric of :math:`S^3`, which is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">        d(q_1, q_2) = \\min(|| \\log(q_1 * \\overline{q_2})||,</span>
<span class="sd">                            2 \\pi - || \\log(q_1 * \\overline{q_2})||)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q1 : array-like, shape (4,)</span>
<span class="sd">        First quaternion</span>

<span class="sd">    q2 : array-like, shape (4,)</span>
<span class="sd">        Second quaternion</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dist : float</span>
<span class="sd">        Distance between q1 and q2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">check_quaternion</span><span class="p">(</span><span class="n">q1</span><span class="p">)</span>
    <span class="n">q2</span> <span class="o">=</span> <span class="n">check_quaternion</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span>
    <span class="n">q12c</span> <span class="o">=</span> <span class="n">concatenate_quaternions</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q_conj</span><span class="p">(</span><span class="n">q2</span><span class="p">))</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">axis_angle_from_quaternion</span><span class="p">(</span><span class="n">q12c</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">angle</span><span class="p">)</span></div>


<div class="viewcode-block" id="quaternion_diff"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.quaternion_diff.html#pytransform3d.rotations.quaternion_diff">[docs]</a><span class="k">def</span> <span class="nf">quaternion_diff</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the rotation in angle-axis format that rotates q2 into q1.</span>

<span class="sd">    .. math::</span>

<span class="sd">        \omega = 2 \log (q_1 * \overline{q_2})</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q1 : array-like, shape (4,)</span>
<span class="sd">        First quaternion</span>

<span class="sd">    q2 : array-line, shape (4,)</span>
<span class="sd">        Second quaternion</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : array-like, shape (4,)</span>
<span class="sd">        The rotation in angle-axis format that rotates q2 into q1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">check_quaternion</span><span class="p">(</span><span class="n">q1</span><span class="p">)</span>
    <span class="n">q2</span> <span class="o">=</span> <span class="n">check_quaternion</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span>
    <span class="n">q1q2c</span> <span class="o">=</span> <span class="n">concatenate_quaternions</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q_conj</span><span class="p">(</span><span class="n">q2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">axis_angle_from_quaternion</span><span class="p">(</span><span class="n">q1q2c</span><span class="p">)</span></div>


<div class="viewcode-block" id="plot_basis"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.plot_basis.html#pytransform3d.rotations.plot_basis">[docs]</a><span class="k">def</span> <span class="nf">plot_basis</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">s</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">ax_s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">strict_check</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Plot basis of a rotation matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ax : Matplotlib 3d axis, optional (default: None)</span>
<span class="sd">        If the axis is None, a new 3d axis will be created</span>

<span class="sd">    R : array-like, shape (3, 3), optional (default: I)</span>
<span class="sd">        Rotation matrix, each column contains a basis vector</span>

<span class="sd">    p : array-like, shape (3,), optional (default: [0, 0, 0])</span>
<span class="sd">        Offset from the origin</span>

<span class="sd">    s : float, optional (default: 1)</span>
<span class="sd">        Scaling of the frame that will be drawn</span>

<span class="sd">    ax_s : float, optional (default: 1)</span>
<span class="sd">        Scaling of the new matplotlib 3d axis</span>

<span class="sd">    strict_check : bool, optional (default: True)</span>
<span class="sd">        Raise a ValueError if the rotation matrix is not numerically close</span>
<span class="sd">        enough to a real rotation matrix. Otherwise we print a warning.</span>

<span class="sd">    kwargs : dict, optional (default: {})</span>
<span class="sd">        Additional arguments for the plotting functions, e.g. alpha</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ax : Matplotlib 3d axis</span>
<span class="sd">        New or old axis</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.plot_utils</span> <span class="kn">import</span> <span class="n">make_3d_axis</span><span class="p">,</span> <span class="n">Frame</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">make_3d_axis</span><span class="p">(</span><span class="n">ax_s</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">check_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">strict_check</span><span class="o">=</span><span class="n">strict_check</span><span class="p">)</span>

    <span class="n">A2B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">A2B</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span>
    <span class="n">A2B</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>

    <span class="n">frame</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="n">A2B</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">frame</span><span class="o">.</span><span class="n">add_frame</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="plot_axis_angle"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.plot_axis_angle.html#pytransform3d.rotations.plot_axis_angle">[docs]</a><span class="k">def</span> <span class="nf">plot_axis_angle</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a_id</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p0</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">ax_s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Plot rotation axis and angle.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ax : Matplotlib 3d axis, optional (default: None)</span>
<span class="sd">        If the axis is None, a new 3d axis will be created</span>

<span class="sd">    a : array-like, shape (4,), optional (default: [1, 0, 0, 0])</span>
<span class="sd">        Axis of rotation and rotation angle: (x, y, z, angle)</span>

<span class="sd">    p : array-like, shape (3,), optional (default: [0, 0, 0])</span>
<span class="sd">        Offset from the origin</span>

<span class="sd">    s : float, optional (default: 1)</span>
<span class="sd">        Scaling of the axis and angle that will be drawn</span>

<span class="sd">    ax_s : float, optional (default: 1)</span>
<span class="sd">        Scaling of the new matplotlib 3d axis</span>

<span class="sd">    kwargs : dict, optional (default: {})</span>
<span class="sd">        Additional arguments for the plotting functions, e.g. alpha</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ax : Matplotlib 3d axis</span>
<span class="sd">        New or old axis</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.plot_utils</span> <span class="kn">import</span> <span class="n">make_3d_axis</span><span class="p">,</span> <span class="n">Arrow3D</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">check_axis_angle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">make_3d_axis</span><span class="p">(</span><span class="n">ax_s</span><span class="p">)</span>

    <span class="n">axis_arrow</span> <span class="o">=</span> <span class="n">Arrow3D</span><span class="p">(</span>
        <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
        <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
        <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
        <span class="n">mutation_scale</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;-|&gt;&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">axis_arrow</span><span class="p">)</span>

    <span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="n">unitx</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="k">else</span>
          <span class="n">perpendicular_to_vectors</span><span class="p">(</span><span class="n">unity</span><span class="p">,</span> <span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">]))</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">perpendicular_to_vectors</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">p1</span><span class="p">)</span>

    <span class="n">angle_p1p2</span> <span class="o">=</span> <span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
    <span class="n">arc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)):</span>
        <span class="n">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">_slerp_weights</span><span class="p">(</span><span class="n">angle_p1p2</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">arc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">w2</span> <span class="o">*</span> <span class="n">p2</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">arc</span><span class="p">[:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">arc</span><span class="p">[:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">arc</span><span class="p">[:</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">arrow_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">arc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">arc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">20</span> <span class="o">*</span> <span class="p">(</span><span class="n">arc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">arc</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">angle_arrow</span> <span class="o">=</span> <span class="n">Arrow3D</span><span class="p">(</span>
        <span class="n">arrow_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arrow_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">arrow_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">mutation_scale</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;-|&gt;&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">angle_arrow</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">arc_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">p</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">s</span> <span class="o">*</span> <span class="n">a</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">arc</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">arc_bound</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arc_bound</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">arc_bound</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="assert_axis_angle_equal"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.assert_axis_angle_equal.html#pytransform3d.rotations.assert_axis_angle_equal">[docs]</a><span class="k">def</span> <span class="nf">assert_axis_angle_equal</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise an assertion if two axis-angle are not approximately equal.</span>

<span class="sd">    Usually we assume that the rotation axis is normalized to length 1 and</span>
<span class="sd">    the angle is within [0, pi). However, this function ignores these</span>
<span class="sd">    constraints and will normalize the representations before comparison.</span>
<span class="sd">    See numpy.testing.assert_array_almost_equal for a more detailed</span>
<span class="sd">    documentation of the other parameters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a1 : array-like, shape (4,)</span>
<span class="sd">        Axis of rotation and rotation angle: (x, y, z, angle)</span>

<span class="sd">    a2 : array-like, shape (4,)</span>
<span class="sd">        Axis of rotation and rotation angle: (x, y, z, angle)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># required despite normalization in case of 180 degree rotation</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">a2</span><span class="p">)):</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="o">-</span><span class="n">a1</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">norm_axis_angle</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">norm_axis_angle</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
    <span class="n">assert_array_almost_equal</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="assert_compact_axis_angle_equal"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.assert_compact_axis_angle_equal.html#pytransform3d.rotations.assert_compact_axis_angle_equal">[docs]</a><span class="k">def</span> <span class="nf">assert_compact_axis_angle_equal</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise an assertion if two axis-angle are not approximately equal.</span>

<span class="sd">    Usually we assume that the angle is within [0, pi). However, this function</span>
<span class="sd">    ignores this constraint and will normalize the representations before</span>
<span class="sd">    comparison. See numpy.testing.assert_array_almost_equal for a more detailed</span>
<span class="sd">    documentation of the other parameters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a1 : array-like, shape (3,)</span>
<span class="sd">        Axis of rotation and rotation angle: angle * (x, y, z)</span>

<span class="sd">    a2 : array-like, shape (3,)</span>
<span class="sd">        Axis of rotation and rotation angle: angle * (x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angle1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
    <span class="n">angle2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
    <span class="c1"># required despite normalization in case of 180 degree rotation</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">angle1</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">angle2</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="ow">and</span>
        <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">a2</span><span class="p">))):</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="o">-</span><span class="n">a1</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">norm_compact_axis_angle</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">norm_compact_axis_angle</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
    <span class="n">assert_array_almost_equal</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="assert_quaternion_equal"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.assert_quaternion_equal.html#pytransform3d.rotations.assert_quaternion_equal">[docs]</a><span class="k">def</span> <span class="nf">assert_quaternion_equal</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise an assertion if two quaternions are not approximately equal.</span>

<span class="sd">    Note that quaternions are equal either if q1 == q2 or if q1 == -q2. See</span>
<span class="sd">    numpy.testing.assert_array_almost_equal for a more detailed documentation</span>
<span class="sd">    of the other parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">assert_array_almost_equal</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
        <span class="n">assert_array_almost_equal</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="o">-</span><span class="n">q2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="assert_euler_xyz_equal"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.assert_euler_xyz_equal.html#pytransform3d.rotations.assert_euler_xyz_equal">[docs]</a><span class="k">def</span> <span class="nf">assert_euler_xyz_equal</span><span class="p">(</span><span class="n">e_xyz1</span><span class="p">,</span> <span class="n">e_xyz2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise an assertion if two xyz Euler angles are not approximately equal.</span>

<span class="sd">    Note that Euler angles are only unique if we limit them to the intervals</span>
<span class="sd">    [-pi, pi], [-pi/2, pi/2], and [-pi, pi] respectively. See</span>
<span class="sd">    numpy.testing.assert_array_almost_equal for a more detailed documentation</span>
<span class="sd">    of the other parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R1</span> <span class="o">=</span> <span class="n">matrix_from_euler_xyz</span><span class="p">(</span><span class="n">e_xyz1</span><span class="p">)</span>
    <span class="n">R2</span> <span class="o">=</span> <span class="n">matrix_from_euler_xyz</span><span class="p">(</span><span class="n">e_xyz2</span><span class="p">)</span>
    <span class="n">assert_array_almost_equal</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="assert_euler_zyx_equal"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.assert_euler_zyx_equal.html#pytransform3d.rotations.assert_euler_zyx_equal">[docs]</a><span class="k">def</span> <span class="nf">assert_euler_zyx_equal</span><span class="p">(</span><span class="n">e_zyx1</span><span class="p">,</span> <span class="n">e_zyx2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise an assertion if two zyx Euler angles are not approximately equal.</span>

<span class="sd">    Note that Euler angles are only unique if we limit them to the intervals</span>
<span class="sd">    [-pi, pi], [-pi/2, pi/2], and [-pi, pi] respectively. See</span>
<span class="sd">    numpy.testing.assert_array_almost_equal for a more detailed documentation</span>
<span class="sd">    of the other parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R1</span> <span class="o">=</span> <span class="n">matrix_from_euler_zyx</span><span class="p">(</span><span class="n">e_zyx1</span><span class="p">)</span>
    <span class="n">R2</span> <span class="o">=</span> <span class="n">matrix_from_euler_zyx</span><span class="p">(</span><span class="n">e_zyx2</span><span class="p">)</span>
    <span class="n">assert_array_almost_equal</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="assert_rotation_matrix"><a class="viewcode-back" href="../../_apidoc/pytransform3d.rotations.assert_rotation_matrix.html#pytransform3d.rotations.assert_rotation_matrix">[docs]</a><span class="k">def</span> <span class="nf">assert_rotation_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise an assertion if a matrix is not a rotation matrix.</span>

<span class="sd">    The two properties :math:`\\boldsymbol{I} = \\boldsymbol{R R}^T` and</span>
<span class="sd">    :math:`det(R) = 1` will be checked. See</span>
<span class="sd">    numpy.testing.assert_array_almost_equal for a more detailed documentation</span>
<span class="sd">    of the other parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">assert_array_almost_equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">assert_array_almost_equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2014-2020, Alexander Fabisch, DFKI GmbH, Robotics Innovation Center.<br/>
      Last updated on Dec 14, 2020.<br/>
    </p>
  </div>
</footer>
  </body>
</html>